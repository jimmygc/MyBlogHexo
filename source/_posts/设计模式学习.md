title: 设计模式学习
date: 2015-10-26 14:18:22
tags:
---

######工厂模式
实现同一接口的类由工厂类中的一个或多个方法控制生成实例。工厂类可为静态类，可实现工厂类接口，实现抽象工厂模式。方便代码拓展，无需修改旧代码。

######单例模式
这个JVM只有一个单例对象，需考虑多线程同步问题，可通过影子实例更新单例对象。

######创造者模式
创造一个拥有多个成员变量的复合对象的类，对复合对象中的每个成员变量进行生成最终组合成复合对象。
Builer实现统一接口或继承于同一抽象类，由Director调用其方法实现构建。Builder变成可替换的组件，不同的Product由不同的Builder完成。

######原型模式
复制对象，比new有更好的性能

######适配器模式
为已有类添加方法以适应接口，已有类缺少方法。
类的适配器模式：适配器类使用继承
对象的适配器模式：实例化已有类成为私有对象
接口的适配器模式：创建抽象类实现所有接口中的方法，新类继承该抽象类。

######装饰模式
对类中的方法进行装饰。装饰类实现与原类相同的接口，原类实例化成为装饰类的一个私有对象，由接口中的函数对原有方法进行装饰。

######代理模式
与装饰模式类似，装饰类的原类在外部实例化赋值，代理类的原类在它实例化的时候实例化。

######外观模式
由一个类来管理多个有联系的类，实现解耦的目的。用户只需要外观类的方法，方便添加组件。

######桥接模式
与对象的适配器模式相似，不同点是桥接模式先有桥，两端的类可以改变，而适配器模式两边固定，使用适配器类使两端能兼容。

######组合模式
类似于树，多个类实现一个接口，使用户对于这个组合能使用统一的方法进行操作。

######享元模式
实现一个对象的共享池，通常与工厂模式合用，工厂类生成对象，由享元模式分配对象。实现资源共享，避免每次都new的开销。

######策略模式
多个类实现一个接口，实现算法的可替换性。

######模版方法模式
多个子类继承一个类

######观察者模式
由一个类在需要更新时更新观察者类，被观察者继承一个抽象类，抽象类里保存观察者列表。类似与RSS订阅模式。

######迭代子模式
由集合类生成Iterator，并由Iterator对集合类中的元素进行迭代。（next（））

######责任链模式
利用接口和继承把多个实现和继承统一接口的类连起来，一个用户请求发送给第一个类，依次传递，直到被处理。

######命令模式
命令类实现一个接口，用户只需要调用这一接口中的方法，命令类多用于对复杂参数的封装，可用于每个操作都需要进行一些特殊处理的情况。

######备忘录模式
使用备忘录类将类里面的变量保存起来到另一个类中，以便之后还原。

######状态模式
在状态类中输入一个类（相同接口或继承），根据类属性的不同调用不同的方法处理。

######访问者模式
访问者实现了对数据结构的操作，被访问者保存了数据结构，用户将访问者注入被访问者，由被访问者调用访问者的方法对被访问者中的数据进行读取。由于是多个访问者读取同一数据结构，所以数据结构的修改涉及代码较多，适宜用于数据结构稳定的系统。

######中介者模式
中介者类包含的多个统一接口的类，由中介者类统一进行调度和关系处理，使两个有关系的类解耦。

######解释器模式
多用于对语法解释器的实现。




